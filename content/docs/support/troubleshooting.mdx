---
title: SoluciÃ³n de Problemas
description: Troubleshooting y preguntas frecuentes del sistema GITAF
---

import { Callout } from 'fumadocs-ui/components/callout';

## Problemas Comunes y Soluciones

### ğŸ”Œ Hardware y Conexiones

#### ESP32 No Enciende

**SÃ­ntomas**: LED del ESP32 no enciende, no responde al USB

**DiagnÃ³stico**:
```bash
# Windows - Ver dispositivos USB
Get-PnpDevice | Where-Object {$_.Status -eq "OK"}

# Linux/macOS
lsusb
dmesg | grep tty
```

**Soluciones**:

<Callout type="warn">
1. **Verificar alimentaciÃ³n**:
   - Medir voltaje en pin VIN/5V (debe ser 4.5-5.5V)
   - Probar con otro cable USB (muchos cables son solo de carga)
   - Probar con otro puerto USB o adaptador de corriente
</Callout>

2. **Verificar regulador**:
   - Medir pin 3V3 (debe ser 3.28-3.35V)
   - Si no hay 3.3V pero sÃ­ hay 5V, el regulador LDO estÃ¡ daÃ±ado

3. **Botones BOOT y EN**:
   - Mantener presionado BOOT + EN
   - Soltar EN primero, luego BOOT
   - Debe entrar en modo bootloader

**Si nada funciona**: Posible chip daÃ±ado. Reemplazar ESP32.

#### BaterÃ­a No Carga

**SÃ­ntomas**: LED rojo del TP4056 no enciende, o parpadea

**Checklist**:
- [ ] USB proporciona 5V (medir con multÃ­metro)
- [ ] BaterÃ­a estÃ¡ conectada correctamente (+/- no invertidos)
- [ ] BaterÃ­a no estÃ¡ completamente descargada (&lt;2.5V)
- [ ] Resistencia Rprog presente y correcta (~1.2kÎ© para 1A)

```
DiagnÃ³stico de LEDs TP4056:

ğŸ”´ Rojo ON, Azul OFF    â†’ Cargando (OK)
ğŸ”µ Rojo OFF, Azul ON    â†’ Carga completa (OK)
âš« Ambos OFF             â†’ Sin conexiÃ³n USB o baterÃ­a
ğŸ”´ Rojo parpadeante     â†’ Temperatura alta o baterÃ­a defectuosa
ğŸ”´ğŸ”µ Ambos ON           â†’ Error crÃ­tico del mÃ³dulo
```

**Si baterÃ­a < 2.5V** (descarga profunda):
```cpp
// Recuperar baterÃ­a con carga lenta
// Conectar resistor de 10Î© en serie con USB
// Cargar 30 min hasta que alcance 3.0V
// Luego conectar normalmente
```

<Callout type="danger">
**âš ï¸ NUNCA** cargues una baterÃ­a Li-Po hinchada, caliente o daÃ±ada fÃ­sicamente. DescÃ¡rtala de forma segura.
</Callout>

#### No Hay Sonido del Altavoz

**DiagnÃ³stico paso a paso**:

1. **Test del DAC directamente**:
```cpp
void testDAC() {
  // Conectar audÃ­fonos con resistor 100Î© en serie a GPIO25
  for(int i = 0; i < 3; i++) {
    dacWrite(25, 128 + 50 * sin(millis() / 100.0));
    delay(10);
  }
  // Â¿Escuchas tono? â†’ DAC funciona
}
```

2. **Test del amplificador**:
   - Verifica 3.3V en VCC del PAM8403
   - Mide voltaje en IN+ (debe variar entre 0-3.3V)
   - Conecta audÃ­fonos directamente a salida de PAM8403

3. **Test del altavoz**:
   - Medir resistencia: debe ser 3-5Î© para altavoz de 4Î©
   - Si es âˆÎ© (abierto), la bobina estÃ¡ quemada
   - Conectar altavoz directamente a fuente con resistor (test de movimiento)

**Matriz de diagnÃ³stico**:

| DAC | Amplificador | Altavoz | Problema |
|-----|--------------|---------|----------|
| âœ… | âœ… | âœ… | Revisar volumen en cÃ³digo |
| âœ… | âœ… | âŒ | Altavoz daÃ±ado |
| âœ… | âŒ | - | PAM8403 daÃ±ado o mal conectado |
| âŒ | - | - | ESP32 o pin daÃ±ado |

### ğŸ“¡ ComunicaciÃ³n ESP-NOW

#### Dispositivos No se Comunican

**SÃ­ntoma**: Maestro envÃ­a pero esclavo no recibe

**VerificaciÃ³n 1: Direcciones MAC**

```cpp
void printMAC() {
  WiFi.mode(WIFI_STA);
  Serial.print("Mi MAC: ");
  Serial.println(WiFi.macAddress());
  
  // Comparar con MACs en config.h
}
```

**VerificaciÃ³n 2: Canal WiFi**

```cpp
void checkWiFiChannel() {
  uint8_t primary;
  wifi_second_chan_t second;
  esp_wifi_get_channel(&primary, &second);
  
  Serial.print("Canal WiFi: ");
  Serial.println(primary);
  
  // Ambos dispositivos deben estar en mismo canal
}
```

**VerificaciÃ³n 3: Callback registrado**

```cpp
// EN ESCLAVO - asegÃºrate que este cÃ³digo existe:
void setup() {
  WiFi.mode(WIFI_STA);
  esp_now_init();
  esp_now_register_recv_cb(OnDataRecv);  // â† CRUCIAL
}
```

**Debugging completo**:

```cpp
void debugESPNOW() {
  Serial.println("\n=== ESP-NOW Debug ===");
  
  // 1. WiFi Mode
  Serial.print("WiFi Mode: ");
  Serial.println(WiFi.getMode());  // Debe ser WIFI_STA (1)
  
  // 2. MAC Address
  Serial.print("MAC: ");
  Serial.println(WiFi.macAddress());
  
  // 3. Canal
  uint8_t channel;
  wifi_second_chan_t second;
  esp_wifi_get_channel(&channel, &second);
  Serial.print("Canal: ");
  Serial.println(channel);
  
  // 4. Peers registrados (solo maestro)
  esp_now_peer_num_t peerNum;
  esp_now_get_peer_num(&peerNum);
  Serial.print("Peers: ");
  Serial.println(peerNum.total_num);
  
  // 5. Potencia TX
  int8_t power;
  esp_wifi_get_max_tx_power(&power);
  Serial.print("TX Power: ");
  Serial.print(power);
  Serial.println(" dBm");
}
```

#### PÃ©rdida de Paquetes

**SÃ­ntomas**: Mensajes llegan esporÃ¡dicamente, no de forma confiable

**Causas**:
1. **Interferencia WiFi**: Otro router en mismo canal
2. **Distancia excesiva**: >100m con obstÃ¡culos
3. **CongestiÃ³n de 2.4GHz**: Muchos dispositivos BT/WiFi
4. **Antena no Ã³ptima**: OrientaciÃ³n o daÃ±o fÃ­sico

**Soluciones**:

```cpp
// 1. Cambiar canal WiFi
void setOptimalChannel() {
  esp_wifi_set_channel(1, WIFI_SECOND_CHAN_NONE);
  // Canales recomendados: 1, 6, 11 (menos overlap)
}

// 2. Aumentar potencia
void increaseRange() {
  esp_wifi_set_max_tx_power(84);  // MÃ¡ximo: 84 (20dBm)
}

// 3. Retry automÃ¡tico
void sendReliable(uint8_t *mac, gitaf_message *msg) {
  for(int attempt = 0; attempt < 3; attempt++) {
    esp_err_t result = esp_now_send(mac, (uint8_t*)msg, sizeof(*msg));
    
    if(result == ESP_OK) {
      Serial.println("Enviado OK");
      return;
    }
    
    Serial.print("Reintento ");
    Serial.println(attempt + 1);
    delay(10);
  }
  
  Serial.println("FALLO despuÃ©s de 3 intentos");
}

// 4. Monitoreo de calidad de seÃ±al
void monitorRSSI() {
  // Solo funciona si hay conexiÃ³n WiFi
  int32_t rssi = WiFi.RSSI();
  Serial.print("RSSI: ");
  Serial.print(rssi);
  Serial.println(" dBm");
  
  if(rssi > -50) Serial.println("Excelente");
  else if(rssi > -60) Serial.println("Bueno");
  else if(rssi > -70) Serial.println("Regular");
  else Serial.println("DÃ©bil");
}
```

#### Mensajes Corruptos

**SÃ­ntoma**: Checksum falla, datos recibidos incorrectos

**Causa**: Ruido elÃ©ctrico, interferencia, bug en cÃ³digo

**VerificaciÃ³n**:

```cpp
void validateMessage(gitaf_message *msg) {
  // 1. Verificar rango de valores
  if(msg->deviceID > 3) {
    Serial.println("ERROR: deviceID invÃ¡lido");
    return;
  }
  
  if(msg->command > 10) {
    Serial.println("ERROR: comando invÃ¡lido");
    return;
  }
  
  if(msg->volume > 255) {
    Serial.println("ERROR: volumen invÃ¡lido");
    return;
  }
  
  // 2. Calcular checksum
  uint8_t calculated = calculateChecksum(msg);
  
  if(calculated != msg->checksum) {
    Serial.println("ERROR: Checksum no coincide");
    Serial.print("Calculado: 0x");
    Serial.print(calculated, HEX);
    Serial.print(" | Recibido: 0x");
    Serial.println(msg->checksum, HEX);
    return;
  }
  
  Serial.println("Mensaje vÃ¡lido");
}
```

### ğŸ”‹ EnergÃ­a y BaterÃ­a

#### ESP32 se Reinicia Aleatoriamente

**SÃ­ntomas**: "rst:0x8 (TG1WDT_SYS_RESET)" o "Brownout detector was triggered"

**Causas**:
1. **Brownout**: Voltaje cae &lt;2.8V momentÃ¡neamente
2. **Pico de corriente**: Audio consume mÃ¡s de lo que baterÃ­a puede dar
3. **Watchdog Timer**: CÃ³digo bloqueado &gt;8 segundos

**Soluciones**:

```cpp
// 1. Desactivar detector de brownout (temporalmente para debug)
void setup() {
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0);  // Â¡Usar con cuidado!
}

// 2. Agregar capacitor de desacople (hardware)
// 100ÂµF entre VIN y GND, cerca del ESP32

// 3. Reducir CPU freq cuando no se usa
void reducePower() {
  setCpuFrequencyMhz(80);  // De 240MHz a 80MHz
}

// 4. Alimentar watchdog
void setup() {
  enableLoopWDT();  // Habilitar watchdog
}

void loop() {
  feedLoopWDT();  // Alimentar cada iteraciÃ³n
  
  // Tu cÃ³digo aquÃ­
  
  delay(10);
}

// 5. Monitorear voltaje en tiempo real
void checkBrownout() {
  float voltage = readBatteryVoltage();
  
  if(voltage < 3.3) {
    Serial.println("âš ï¸ VOLTAJE BAJO - Reduciendo consumo");
    
    // Reducir CPU
    setCpuFrequencyMhz(80);
    
    // Bajar volumen de audio
    audioManager.setVolume(150);
    
    // Avisar al maestro
    sendLowBatteryAlert();
  }
  
  if(voltage < 3.0) {
    Serial.println("ğŸ”´ CRÃTICO - Apagando");
    esp_deep_sleep_start();
  }
}
```

#### BaterÃ­a Dura Muy Poco

**Mediciones de consumo**:

```cpp
void analyzePowerConsumption() {
  float vBefore = readBatteryVoltage();
  unsigned long tStart = millis();
  
  // Tu cÃ³digo a medir
  audioManager.play(2000, 10000);  // 10s de audio
  
  unsigned long tEnd = millis();
  float vAfter = readBatteryVoltage();
  
  float voltageDropped = vBefore - vAfter;
  float timeHours = (tEnd - tStart) / 3600000.0;
  
  // EstimaciÃ³n de consumo
  // I = Î”V / (R * Î”t), aproximadamente
  float mAh_consumed = (voltageDropped * 2000) / 3.7;  // Para baterÃ­a 2000mAh
  
  Serial.print("Consumo estimado: ");
  Serial.print(mAh_consumed);
  Serial.println(" mAh");
  
  Serial.print("AutonomÃ­a proyectada: ");
  Serial.print(2000 / (mAh_consumed / timeHours));
  Serial.println(" horas");
}
```

**Optimizaciones**:

```cpp
// Reducir consumo en espera
void enterLightSleep() {
  esp_sleep_enable_timer_wakeup(100000);  // 100ms
  esp_light_sleep_start();
  
  // Consumo: ~2mA vs 100mA activo
}

// Apagar mÃ³dulos no usados
void disableUnusedModules() {
  // Apagar Bluetooth si no se usa
  btStop();
  
  // Apagar WiFi si solo usas ESP-NOW
  // (NO hacer esto - ESP-NOW necesita WiFi stack)
  
  // Apagar ADC si no monitoreas baterÃ­a
  adc_power_off();
}

// Smart Sleep entre comandos
unsigned long lastActivity = 0;

void loop() {
  if(millis() - lastActivity > 30000) {
    // 30s sin actividad
    Serial.println("Entrando en sleep...");
    esp_light_sleep_start();
  }
  
  // Procesar comandos ESP-NOW
  // (OnDataRecv se llama aunque estÃ©s en light sleep)
}
```

### ğŸ’» Software y Firmware

#### "Sketch too big" al Compilar

**Error**: Sketch uses 120% of program storage space

**Causas**:
- Muchas librerÃ­as incluidas
- Debug symbols habilitados
- Partition scheme incorrecta

**Soluciones**:

1. **Cambiar partition scheme**:
   - Tools â†’ Partition Scheme â†’ "No OTA (2MB APP/2MB SPIFFS)"
   - O "Minimal SPIFFS (1.9MB APP with OTA)"

2. **Optimizar compilaciÃ³n**:
```ini
# platformio.ini
build_flags = 
    -Os                     # Optimizar por tamaÃ±o
    -DCORE_DEBUG_LEVEL=0   # Sin debug
    -ffunction-sections
    -fdata-sections
```

3. **Remover cÃ³digo no usado**:
```cpp
// Comentar includes no necesarios
// #include <WiFiClient.h>  // No usado
// #include <HTTPClient.h>   // No usado

// Usar forward declarations
class AudioManager;  // En lugar de #include "audio_manager.h"
```

4. **Ver tamaÃ±o de secciones**:
```bash
# Linux/macOS
xtensa-esp32-elf-nm -S --size-sort build/*.elf | tail -20

# Windows (en PowerShell de PlatformIO)
pio run --target size
```

#### Upload Falla: "Timed out waiting for packet header"

**Soluciones**:

1. **MÃ©todo BOOT manual**:
   - Mantener BOOT presionado
   - Click "Upload"
   - Cuando vea "Connecting...", soltar BOOT

2. **Agregar delay en setup()**:
```cpp
void setup() {
  delay(3000);  // 3s de tiempo para conectar
  Serial.begin(115200);
  // resto del cÃ³digo
}
```

3. **Bajar velocidad de upload**:
   - Tools â†’ Upload Speed â†’ "115200" (en lugar de 921600)

4. **Resetear configuraciÃ³n**:
```cpp
void resetESP32() {
  esp_wifi_restore();  // Restaurar config WiFi
  ESP.restart();
}
```

#### Monitor Serial Muestra Caracteres ExtraÃ±os

**Causa**: Baud rate incorrecto

**SoluciÃ³n**:
```cpp
void setup() {
  Serial.begin(115200);  // Asegurar 115200
  while(!Serial) delay(10);
  
  Serial.println("\n\n=== GITAF Started ===");
}
```

En Arduino IDE:
- Tools â†’ Monitor Serial â†’ 115200 baud

En PlatformIO:
```ini
monitor_speed = 115200
monitor_filters = 
    esp32_exception_decoder  # Decodificar stack traces
    default
```

### ğŸ“± IntegraciÃ³n con App

#### App No Encuentra el Dispositivo Bluetooth

**En el ESP32**:

```cpp
void setupBLE() {
  BLEDevice::init("GITAF-Master");  // Nombre visible
  BLEServer *pServer = BLEDevice::createServer();
  
  // Asegurar que advertising estÃ© activo
  BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
  pAdvertising->start();
  
  Serial.println("BLE Advertising iniciado");
  Serial.print("Nombre: ");
  Serial.println("GITAF-Master");
}
```

**En la App Android**:
- Verificar permisos BLUETOOTH_SCAN y ACCESS_FINE_LOCATION
- Android 12+ requiere BLUETOOTH_CONNECT

#### Comandos Bluetooth No llegan a ESP-NOW

**Debug del flujo**:

```cpp
// En el maestro
void onBLEcommand(uint8_t postID) {
  Serial.print("BLE â†’ Comando recibido: POST_");
  Serial.println(postID);
  
  // Verificar que ESP-NOW estÃ¡ inicializado
  if(esp_now_is_peer_exist(slaveLeftMAC)) {
    Serial.println("ESP-NOW â†’ Peer existe, enviando...");
    
    sendCommand(postID, CMD_PLAY_AUDIO);
    
    Serial.println("ESP-NOW â†’ Comando enviado");
  } else {
    Serial.println("ERROR: Peer no existe!");
    initESPNOW();  // Reinicializar
  }
}
```

## Comandos de DiagnÃ³stico Ãštiles

### Monitor Serial Avanzado

```cpp
void printSystemInfo() {
  Serial.println("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  Serial.println("â•‘  GITAF System Info");
  Serial.println("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  
  // VersiÃ³n firmware
  Serial.print("â•‘ Firmware: ");
  Serial.println(FIRMWARE_VERSION);
  
  // Tipo de dispositivo
  Serial.print("â•‘ Tipo: ");
  Serial.println(DEVICE_TYPE);
  
  // Chip ID
  Serial.print("â•‘ Chip ID: 0x");
  Serial.println(ESP.getEfuseMac(), HEX);
  
  // MAC Address
  Serial.print("â•‘ MAC: ");
  Serial.println(WiFi.macAddress());
  
  // CPU Freq
  Serial.print("â•‘ CPU: ");
  Serial.print(getCpuFrequencyMhz());
  Serial.println(" MHz");
  
  // Memoria
  Serial.print("â•‘ Heap libre: ");
  Serial.print(ESP.getFreeHeap() / 1024);
  Serial.println(" KB");
  
  // BaterÃ­a
  float voltage = readBatteryVoltage();
  Serial.print("â•‘ BaterÃ­a: ");
  Serial.print(voltage);
  Serial.print("V (");
  Serial.print(getBatteryPercentage(voltage));
  Serial.println("%)");
  
  // Uptime
  Serial.print("â•‘ Uptime: ");
  Serial.print(millis() / 1000);
  Serial.println(" s");
  
  Serial.println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
}
```

### Test de Hardware Completo

```cpp
void fullSystemTest() {
  Serial.println("\n*** TEST COMPLETO DEL SISTEMA ***\n");
  
  // 1. Test LED
  Serial.println("[1/6] Test LED...");
  testLED();
  delay(1000);
  
  // 2. Test DAC
  Serial.println("[2/6] Test DAC/Audio...");
  testAudioSystem();
  delay(1000);
  
  // 3. Test ESP-NOW
  Serial.println("[3/6] Test ESP-NOW...");
  debugESPNOW();
  delay(1000);
  
  // 4. Test BaterÃ­a
  Serial.println("[4/6] Test BaterÃ­a...");
  testBattery();
  delay(1000);
  
  // 5. Test Memoria
  Serial.println("[5/6] Test Memoria...");
  testMemory();
  delay(1000);
  
  // 6. Test Conectividad
  Serial.println("[6/6] Test Conectividad...");
  testConnectivity();
  
  Serial.println("\n*** TEST COMPLETADO ***\n");
}
```

## Preguntas Frecuentes (FAQ)

<details>
<summary>**Â¿Puedo usar ESP8266 en lugar de ESP32?**</summary>

No recomendado. ESP8266 no tiene:
- DAC (necesitarÃ­as mÃ³dulo externo)
- Dual-core (peor manejo de ESP-NOW + Audio)
- Menos RAM (160KB vs 520KB)

Aunque tÃ©cnicamente posible, el ESP32 es mucho mejor para este proyecto.

</details>

<details>
<summary>**Â¿CuÃ¡nta distancia puedo cubrir con ESP-NOW?**</summary>

En campo abierto: hasta 200-250 metros
Con obstÃ¡culos: 50-100 metros
En interiores: 30-50 metros

El alcance depende de:
- OrientaciÃ³n de las antenas
- Interferencias (WiFi, BT, microondas)
- ObstÃ¡culos (paredes, metal)
- Potencia de transmisiÃ³n configurada

</details>

<details>
<summary>**Â¿Puedo agregar mÃ¡s de 3 postes?**</summary>

SÃ­. ESP-NOW soporta hasta **20 dispositivos esclavos** por maestro.

Solo necesitas:
1. Agregar mÃ¡s entries en el array de MACs
2. Actualizar la app para tener mÃ¡s botones
3. Programar los ESP32 adicionales como esclavos

</details>

<details>
<summary>**Â¿Funciona bajo lluvia?**</summary>

Solo si las cajas son **IP65+** (resistentes al agua).

Recomendaciones:
- Sellar todas las aberturas con silicona
- Usar conectores impermeables
- Bolsas zip como backup en lluvia fuerte
- Nunca cargar mÃ³dulos mojados

</details>

<details>
<summary>**Â¿Puedo usar baterÃ­as de mayor capacidad?**</summary>

SÃ­. Puedes usar hasta 5000-6000 mAh sin problemas.

Consideraciones:
- Mayor peso en los postes
- Mayor tiempo de carga
- Verificar que TP4056 soporte corriente de descarga

</details>

## Obtener MÃ¡s Ayuda

### Reportar un Bug

**Antes de reportar**:
1. Corre `fullSystemTest()` y guarda el Log
2. Anota versiÃ³n de firmware
3. Describe pasos para reproducir
4. Incluye fotos de conexiones si es problema de hardware

**DÃ³nde reportar**:
- GitHub Issues: [github.com/tu-usuario/gitaf/issues](https://github.com)
- Email: soporte@gitaf.com
- Foro: forum.gitaf.com

### Logs Ãštiles para Soporte

```cpp
void generateDiagnosticLog() {
  Serial.println("\n===== DIAGNOSTIC LOG =====");
  Serial.println("Generated: " + String(millis()/1000) + "s after boot");
  
  printSystemInfo();
  debugESPNOW();
  testBattery();
  
  // Ãšltimos errores
  Serial.println("\n--- Ãšltimos Errores ---");
  // AquÃ­ puedes agregar un buffer circular de errores
  
  Serial.println("\n===== END LOG =====\n");
  
  // Copiar todo el output y enviarlo a soporte
}
```

## Recursos Adicionales

- ğŸ“– [DocumentaciÃ³n Completa](/docs/introduction)
- ğŸ’» [GitHub Repository](https://github.com/tu-usuario/gitaf)
- ğŸ¥ [Video Tutorials](https://youtube.com/gitaf)
- ğŸ’¬ [Community Forum](https://forum.gitaf.com)
- ğŸ“§ [Contacto: soporte@gitaf.com](mailto:soporte@gitaf.com)
